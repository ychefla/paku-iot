name: OTA Update ESP Devices

"on":
  workflow_dispatch:
    inputs:
      rollout_strategy:
        description: 'Rollout strategy'
        required: true
        type: choice
        options:
          - single-device
          - canary-10
          - canary-25
          - canary-50
          - full
        default: 'single-device'
      device_model:
        description: 'Device model'
        required: true
        type: choice
        options:
          - lilygo-t-display-s3
          - esp32-ch340c-30pin
          - esp8266-wired-sensors
        default: 'lilygo-t-display-s3'
      test_devices:
        description: 'Device IDs (comma-separated, only for single-device strategy)'
        required: false
        type: string
        default: ''
      additional_ssid:
        description: 'Additional WiFi SSID (optional, for site-specific deployment)'
        required: false
        type: string
        default: ''
      additional_password:
        description: 'Additional WiFi password (optional)'
        required: false
        type: string
        default: ''
      release_notes:
        description: 'Release notes'
        required: false
        type: string
        default: 'Automated OTA update from paku-core main branch'

permissions:
  contents: read

jobs:
  build-and-deploy-ota:
    name: Build and Deploy OTA Update
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout paku-core repository
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.PAKU_CORE_REPO || 'ychefla/paku-core' }}
          ref: main
          token: ${{ secrets.PAKU_CORE_TOKEN || github.token }}

      - name: Generate version from commit
        run: |
          # Use short commit hash from paku-core repository (not paku-iot)
          cd paku_core
          PAKU_CORE_COMMIT=$(git rev-parse --short HEAD)
          cd ..
          VERSION="${PAKU_CORE_COMMIT}-$(date +%Y%m%d-%H%M%S)"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Generated version from paku-core commit: $VERSION"
          
          # Store just the commit hash for firmware existence check
          echo "COMMIT_HASH=$PAKU_CORE_COMMIT" >> $GITHUB_ENV

      - name: Check if firmware already exists
        id: check_firmware
        env:
          OTA_URL: ${{ secrets.OTA_SERVICE_URL || 'http://localhost:8080' }}
          DEVICE_MODEL: ${{ github.event.inputs.device_model }}
        run: |
          echo "Checking if firmware already exists for commit: $COMMIT_HASH and model: $DEVICE_MODEL"
          
          # Query OTA service for existing firmware releases matching this commit hash
          response=$(curl -s "${OTA_URL}/api/admin/firmware/releases?device_model=${DEVICE_MODEL}&limit=50" || echo '{"releases":[]}')
          
          # Check if any release version starts with this commit hash
          existing_version=$(echo "$response" | jq -r ".releases[]? | select(.version | startswith(\"${COMMIT_HASH}-\")) | .version" | head -n1)
          
          if [ -n "$existing_version" ]; then
            echo "Found existing firmware: $existing_version"
            echo "FIRMWARE_EXISTS=true" >> $GITHUB_ENV
            echo "EXISTING_VERSION=$existing_version" >> $GITHUB_ENV
            echo "firmware_exists=true" >> $GITHUB_OUTPUT
            
            # Get checksum for existing firmware
            checksum=$(echo "$response" | jq -r ".releases[]? | select(.version == \"${existing_version}\") | .checksum_sha256")
            echo "FIRMWARE_SHA256=$checksum" >> $GITHUB_ENV
            echo "Using existing firmware: $existing_version (SHA256: $checksum)"
          else
            echo "No existing firmware found, build required"
            echo "FIRMWARE_EXISTS=false" >> $GITHUB_ENV
            echo "firmware_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Set up Python
        if: env.FIRMWARE_EXISTS != 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Cache PlatformIO
        if: env.FIRMWARE_EXISTS != 'true'
        uses: actions/cache@v3
        with:
          path: |
            ~/.platformio
            paku_core/.pio
          key: ${{ runner.os }}-pio-${{ hashFiles('**/platformio.ini') }}
          restore-keys: |
            ${{ runner.os }}-pio-

      - name: Install PlatformIO
        if: env.FIRMWARE_EXISTS != 'true'
        run: |
          pip install --upgrade platformio
          platformio --version

      - name: Copy secrets template
        if: env.FIRMWARE_EXISTS != 'true'
        shell: bash
        env:
          WIFI_SSIDS_SECRET: ${{ secrets.WIFI_SSIDS }}
          WIFI_PASSWORDS_SECRET: ${{ secrets.WIFI_PASSWORDS }}
          MQTT_SERVER_SECRET: ${{ secrets.MQTT_SERVER }}
          ADDITIONAL_SSID: ${{ github.event.inputs.additional_ssid }}
          ADDITIONAL_PASSWORD: ${{ github.event.inputs.additional_password }}
        run: |
          cd paku_core
          # Use template or inject secrets from GitHub Secrets (if provided)
          if [ -n "$WIFI_SSIDS_SECRET" ]; then
            echo "Using WiFi credentials from GitHub Secrets"
            
            # Write secrets to temp files using environment variables (avoids bash parsing)
            printf '%s' "$WIFI_SSIDS_SECRET" > /tmp/ssids.json
            printf '%s' "$WIFI_PASSWORDS_SECRET" > /tmp/passwords.json
            
            # Add additional SSID if provided
            if [ -n "$ADDITIONAL_SSID" ]; then
              echo "Adding additional WiFi network: $ADDITIONAL_SSID"
              
              # Append additional network to arrays
              TEMP_SSIDS=$(jq --arg ssid "$ADDITIONAL_SSID" '. + [$ssid]' /tmp/ssids.json)
              TEMP_PASSWORDS=$(jq --arg pwd "$ADDITIONAL_PASSWORD" '. + [$pwd]' /tmp/passwords.json)
              
              printf '%s' "$TEMP_SSIDS" > /tmp/ssids.json
              printf '%s' "$TEMP_PASSWORDS" > /tmp/passwords.json
            fi
            
            # Convert JSON arrays to C arrays
            SSID_ARRAY=$(jq -r '.[] | @json' /tmp/ssids.json | paste -sd ',' -)
            PASSWORD_ARRAY=$(jq -r '.[] | @json' /tmp/passwords.json | paste -sd ',' -)
            WIFI_COUNT=$(jq '. | length' /tmp/ssids.json)
            
            # Clean up temp files
            rm -f /tmp/ssids.json /tmp/passwords.json
            
            cat > include/secrets.h << EOF
          #pragma once
          
          // Auto-generated from GitHub Secrets for OTA build
          #define LOG_ENABLED 1
          #define LOG_INFO_ENABLED 1
          
          static const char* WIFI_SSIDS[] = { $SSID_ARRAY };
          static const char* WIFI_PASSWORDS[] = { $PASSWORD_ARRAY };
          static const size_t WIFI_COUNT = $WIFI_COUNT;
          
          #define MQTT_SERVER "$MQTT_SERVER_SECRET"
          #define MQTT_PORT 1883
          
          #define PAKU_IOT_ENABLED 0
          #define PAKU_IOT_HOST "localhost"
          #define PAKU_IOT_PORT 443
          #define PAKU_IOT_API_KEY "not-used"
          #define PAKU_IOT_USE_TLS false
          EOF
          else
            echo "Using secrets template (no GitHub Secrets configured)"
            cp include/secrets.h.template include/secrets.h
          fi
          
          # Create device_config.h with the appropriate device based on build environment
          if [[ "${{ github.event.inputs.device_model }}" == *"lilygo"* ]] || [[ "${{ github.event.inputs.device_model }}" == "esp32-s3" ]]; then
            sed 's|// #define DEVICE_LILYGO_T_DISPLAY_S3|#define DEVICE_LILYGO_T_DISPLAY_S3|' src/device_config.h.template > src/device_config.h
            sed -i 's|^#define DEVICE_ESP8266_WIRED_SENSORS|// #define DEVICE_ESP8266_WIRED_SENSORS|' src/device_config.h
          elif [[ "${{ github.event.inputs.device_model }}" == "esp8266"* ]]; then
            cp src/device_config.h.template src/device_config.h
          else
            # Generic ESP32
            sed 's|// #define DEVICE_ESP32_CH340C_30PIN|#define DEVICE_ESP32_CH340C_30PIN|' src/device_config.h.template > src/device_config.h
            sed -i 's|^#define DEVICE_ESP8266_WIRED_SENSORS|// #define DEVICE_ESP8266_WIRED_SENSORS|' src/device_config.h
          fi

      - name: Build firmware
        if: env.FIRMWARE_EXISTS != 'true'
        run: |
          cd paku_core
          echo "Building firmware for ${{ github.event.inputs.device_model }}..."
          platformio run --environment ${{ github.event.inputs.device_model }}
          
          # Find the built firmware (specifically firmware.bin, not partitions.bin)
          FIRMWARE_PATH=".pio/build/${{ github.event.inputs.device_model }}/firmware.bin"
          
          if [ ! -f "$FIRMWARE_PATH" ]; then
            echo "Error: Firmware binary not found at $FIRMWARE_PATH"
            ls -la ".pio/build/${{ github.event.inputs.device_model }}/" || true
            exit 1
          fi
          
          echo "Firmware built successfully: $FIRMWARE_PATH"
          echo "Firmware size: $(stat -c%s "$FIRMWARE_PATH" 2>/dev/null || stat -f%z "$FIRMWARE_PATH") bytes"
          
          # Store path relative to repo root
          echo "FIRMWARE_PATH=paku_core/$FIRMWARE_PATH" >> $GITHUB_ENV
          
          # Calculate checksum
          FIRMWARE_SHA256=$(sha256sum "$FIRMWARE_PATH" | cut -d' ' -f1)
          echo "FIRMWARE_SHA256=$FIRMWARE_SHA256" >> $GITHUB_ENV
          echo "Firmware SHA256: $FIRMWARE_SHA256"

      - name: Upload firmware to OTA service
        if: env.FIRMWARE_EXISTS != 'true'
        env:
          OTA_URL: ${{ secrets.OTA_SERVICE_URL || 'http://localhost:8080' }}
          OTA_API_KEY: ${{ secrets.OTA_API_KEY }}
          DEVICE_MODEL: ${{ github.event.inputs.device_model }}
          RELEASE_NOTES: ${{ github.event.inputs.release_notes }}
        run: |
          echo "Uploading firmware to OTA service..."
          echo "Firmware path: ${FIRMWARE_PATH}"
          echo "Firmware size: $(stat -c%s "${FIRMWARE_PATH}" 2>/dev/null || stat -f%z "${FIRMWARE_PATH}")"
          
          # Install requests library if needed
          pip3 install --quiet requests 2>/dev/null || true
          
          # Use Python requests instead of curl for more reliable multipart upload
          cat > /tmp/upload_firmware.py << 'PYEOF'
          import os
          import sys
          
          try:
              import requests
          except ImportError:
              print("Error: requests library not available")
              sys.exit(1)
          
          firmware_path = os.environ['FIRMWARE_PATH'].strip()
          version = os.environ['VERSION'].strip()
          device_model = os.environ['DEVICE_MODEL'].strip()
          ota_url = os.environ['OTA_URL'].strip()
          api_key = os.environ['OTA_API_KEY'].strip()
          release_notes = os.environ.get('RELEASE_NOTES', '').strip()
          
          url = f"{ota_url}/api/admin/firmware/upload"
          params = {
              "version": version,
              "device_model": device_model,
              "is_signed": "false"
          }
          
          if release_notes:
              params["release_notes"] = release_notes
          
          print(f"Uploading to: {url}")
          print(f"Parameters: {params}")
          
          try:
              headers = {"X-API-Key": api_key}
              with open(firmware_path, 'rb') as f:
                  files = {'file': (os.path.basename(firmware_path), f, 'application/octet-stream')}
                  response = requests.post(url, params=params, headers=headers, files=files, timeout=60)
              
              print(f"Response status: {response.status_code}")
              print(f"Response body: {response.text}")
              
              if response.status_code != 200:
                  print(f"Error: Failed to upload firmware (HTTP {response.status_code})")
                  sys.exit(1)
              
              print("Firmware uploaded successfully!")
              
          except Exception as e:
              print(f"Error uploading firmware: {e}")
              import traceback
              traceback.print_exc()
              sys.exit(1)
          PYEOF
          
          python3 /tmp/upload_firmware.py

      - name: Create rollout configuration
        run: |
          # Use existing version if firmware wasn't built
          if [ "$FIRMWARE_EXISTS" = "true" ]; then
            DEPLOY_VERSION="$EXISTING_VERSION"
            echo "Using existing firmware version: $DEPLOY_VERSION"
            # Add timestamp suffix to make rollout name unique when reusing firmware
            ROLLOUT_SUFFIX="-$(date +%H%M%S)"
          else
            DEPLOY_VERSION="$VERSION"
            echo "Using newly built firmware version: $DEPLOY_VERSION"
            ROLLOUT_SUFFIX=""
          fi
          
          echo "Creating rollout configuration for strategy: ${{ github.event.inputs.rollout_strategy }}..."
          
          STRATEGY="${{ github.event.inputs.rollout_strategy }}"
          ROLLOUT_NAME="${{ github.event.inputs.device_model }}-${DEPLOY_VERSION}-${STRATEGY}${ROLLOUT_SUFFIX}"
          
          # Prepare rollout payload based on strategy
          case "$STRATEGY" in
            single-device)
              if [ -z "${{ github.event.inputs.test_devices }}" ]; then
                echo "Error: test_devices must be provided for single-device strategy"
                exit 1
              fi
              # Convert comma-separated list to JSON array
              DEVICE_ARRAY=$(echo '${{ github.event.inputs.test_devices }}' | jq -R 'split(",") | map(gsub("^\\s+|\\s+$";""))')
              PAYLOAD=$(jq -n \
                --arg name "$ROLLOUT_NAME" \
                --arg version "$DEPLOY_VERSION" \
                --arg model "${{ github.event.inputs.device_model }}" \
                --argjson devices "$DEVICE_ARRAY" \
                '{
                  name: $name,
                  firmware_version: $version,
                  device_model: $model,
                  target_type: "specific",
                  target_device_ids: $devices,
                  is_active: true
                }')
              ;;
            canary-10|canary-25|canary-50)
              PERCENTAGE=$(echo "$STRATEGY" | cut -d- -f2)
              PAYLOAD=$(jq -n \
                --arg name "$ROLLOUT_NAME" \
                --arg version "$DEPLOY_VERSION" \
                --arg model "${{ github.event.inputs.device_model }}" \
                --argjson pct "$PERCENTAGE" \
                '{
                  name: $name,
                  firmware_version: $version,
                  device_model: $model,
                  target_type: "canary",
                  rollout_percentage: $pct,
                  is_active: true
                }')
              ;;
            full)
              PAYLOAD=$(jq -n \
                --arg name "$ROLLOUT_NAME" \
                --arg version "$DEPLOY_VERSION" \
                --arg model "${{ github.event.inputs.device_model }}" \
                '{
                  name: $name,
                  firmware_version: $version,
                  device_model: $model,
                  target_type: "all",
                  is_active: true
                }')
              ;;
            *)
              echo "Error: Unknown rollout strategy: $STRATEGY"
              exit 1
              ;;
          esac
          
          echo "Rollout payload:"
          echo "$PAYLOAD" | jq '.'
          
          # Create rollout
          HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/rollout_response.json \
            -X POST \
            "${{ secrets.OTA_SERVICE_URL || 'http://localhost:8080' }}/api/admin/rollout/create" \
            -H "Content-Type: application/json" \
            -H "X-API-Key: ${{ secrets.OTA_API_KEY }}" \
            -d "$PAYLOAD")
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "Error: Failed to create rollout (HTTP $HTTP_CODE)"
            cat /tmp/rollout_response.json
            exit 1
          fi
          
          echo "Rollout created successfully!"
          if [ -s /tmp/rollout_response.json ]; then
            cat /tmp/rollout_response.json | jq '.' || echo "Warning: Response is not valid JSON"
          else
            echo "Note: No response body returned"
          fi

      - name: Trigger device updates via MQTT
        env:
          OTA_URL: ${{ secrets.OTA_SERVICE_URL || 'http://localhost:8080' }}
          OTA_API_KEY: ${{ secrets.OTA_API_KEY }}
          MQTT_HOST: static.107.192.27.37.clients.your-server.de
          MQTT_PORT: 1883
        run: |
          echo "Installing dependencies..."
          sudo apt-get update -qq
          sudo apt-get install -y mosquitto-clients jq
          
          # Use existing version if firmware wasn't built
          if [ "$FIRMWARE_EXISTS" = "true" ]; then
            DEPLOY_VERSION="$EXISTING_VERSION"
            echo "Deploying existing firmware version: $DEPLOY_VERSION"
          else
            DEPLOY_VERSION="$VERSION"
            echo "Deploying newly built firmware version: $DEPLOY_VERSION"
          fi
          
          STRATEGY="${{ github.event.inputs.rollout_strategy }}"
          DEVICE_MODEL="${{ github.event.inputs.device_model }}"
          FIRMWARE_URL="${{ secrets.OTA_SERVICE_URL || 'http://localhost:8080' }}/api/firmware/download/${DEPLOY_VERSION}"
          
          # Build OTA command JSON
          OTA_COMMAND=$(cat <<EOF
          {
            "url": "$FIRMWARE_URL",
            "version": "$DEPLOY_VERSION",
            "checksum": "$FIRMWARE_SHA256"
          }
          EOF
          )
          
          echo "OTA Command to send:"
          echo "$OTA_COMMAND" | jq '.'
          echo ""
          
          # Function to send OTA command to a device
          send_ota_command() {
            local device_id=$1
            local topic="paku/devices/${device_id}/cmd/ota"
            
            echo "→ Sending to: $device_id"
            
            # Use -m to send as single message (not -l which sends line by line)
            mosquitto_pub \
              -h "$MQTT_HOST" \
              -p "$MQTT_PORT" \
              -t "$topic" \
              -m "$OTA_COMMAND"
            
            if [ $? -eq 0 ]; then
              echo "  ✓ Success"
              return 0
            else
              echo "  ✗ Failed"
              return 1
            fi
          }
          
          # Discover and notify devices based on strategy
          if [ "$STRATEGY" = "single-device" ]; then
            # Single device: use provided device IDs
            if [ -z "${{ github.event.inputs.test_devices }}" ]; then
              echo "Error: No test devices specified for single-device strategy"
              exit 1
            fi
            
            echo "Strategy: Single Device"
            echo "Target devices: ${{ github.event.inputs.test_devices }}"
            echo ""
            
            IFS=',' read -ra DEVICES <<< "${{ github.event.inputs.test_devices }}"
            success_count=0
            fail_count=0
            
            for device_id in "${DEVICES[@]}"; do
              device_id=$(echo "$device_id" | xargs)  # trim whitespace
              if send_ota_command "$device_id"; then
                ((success_count++))
              else
                ((fail_count++))
              fi
            done
            
            echo ""
            echo "Summary: $success_count succeeded, $fail_count failed"
            
          elif [[ "$STRATEGY" == canary-* ]]; then
            # Canary: query database for devices and select percentage
            PERCENTAGE=$(echo "$STRATEGY" | cut -d- -f2)
            
            echo "Strategy: Canary ($PERCENTAGE%)"
            echo "Querying OTA service for devices with model: $DEVICE_MODEL"
            echo ""
            
            # Query devices from OTA service API
            response=$(curl -s -f -H "X-API-Key: $OTA_API_KEY" \
              "${OTA_URL}/api/admin/devices?device_model=${DEVICE_MODEL}&limit=500")
            
            if [ $? -ne 0 ]; then
              echo "Error: Failed to query devices from OTA service"
              exit 1
            fi
            
            # Extract active devices (seen in last 7 days)
            SEVEN_DAYS_AGO=$(date -u -d '7 days ago' '+%Y-%m-%dT%H:%M:%S' 2>/dev/null || date -u -v-7d '+%Y-%m-%dT%H:%M:%S')
            DEVICE_LIST=$(echo "$response" | jq -r ".devices[]? | select(.last_seen > \"$SEVEN_DAYS_AGO\") | .device_id")
            
            if [ -z "$DEVICE_LIST" ]; then
              echo "Warning: No active devices found for model $DEVICE_MODEL"
              echo "Debug: All devices for this model:"
              echo "$response" | jq -r '.devices[]? | "\(.device_id) - last seen: \(.last_seen)"'
              exit 0
            fi
            
            TOTAL_DEVICES=$(echo "$DEVICE_LIST" | wc -l | xargs)
            TARGET_COUNT=$(( TOTAL_DEVICES * PERCENTAGE / 100 ))
            
            if [ $TARGET_COUNT -lt 1 ]; then
              TARGET_COUNT=1
            fi
            
            echo "Found $TOTAL_DEVICES devices"
            echo "Targeting $TARGET_COUNT devices ($PERCENTAGE%)"
            echo ""
            
            success_count=0
            fail_count=0
            count=0
            
            while IFS= read -r device_id; do
              if [ $count -ge $TARGET_COUNT ]; then
                break
              fi
              
              if send_ota_command "$device_id"; then
                ((success_count++))
              else
                ((fail_count++))
              fi
              
              ((count++))
            done <<< "$DEVICE_LIST"
            
            echo ""
            echo "Summary: $success_count succeeded, $fail_count failed out of $TARGET_COUNT targets"
            
          elif [ "$STRATEGY" = "full" ]; then
            # Full: notify all active devices of this model
            echo "Strategy: Full Rollout"
            echo "Querying OTA service for all active devices with model: $DEVICE_MODEL"
            echo ""
            
            # Query devices from OTA service API
            response=$(curl -s -f -H "X-API-Key: $OTA_API_KEY" \
              "${OTA_URL}/api/admin/devices?device_model=${DEVICE_MODEL}&limit=500")
            
            if [ $? -ne 0 ]; then
              echo "Error: Failed to query devices from OTA service"
              exit 1
            fi
            
            # Extract active devices (seen in last 7 days)
            SEVEN_DAYS_AGO=$(date -u -d '7 days ago' '+%Y-%m-%dT%H:%M:%S' 2>/dev/null || date -u -v-7d '+%Y-%m-%dT%H:%M:%S')
            DEVICE_LIST=$(echo "$response" | jq -r ".devices[]? | select(.last_seen > \"$SEVEN_DAYS_AGO\") | .device_id")
            
            if [ -z "$DEVICE_LIST" ]; then
              echo "Warning: No active devices found for model $DEVICE_MODEL"
              echo "Debug: All devices for this model:"
              echo "$response" | jq -r '.devices[]? | "\(.device_id) - last seen: \(.last_seen)"'
              exit 0
            fi
            
            TOTAL_DEVICES=$(echo "$DEVICE_LIST" | wc -l | xargs)
            echo "Found $TOTAL_DEVICES devices"
            echo ""
            
            success_count=0
            fail_count=0
            
            while IFS= read -r device_id; do
              if send_ota_command "$device_id"; then
                ((success_count++))
              else
                ((fail_count++))
              fi
            done <<< "$DEVICE_LIST"
            
            echo ""
            echo "Summary: $success_count succeeded, $fail_count failed out of $TOTAL_DEVICES devices"
          fi
          
          # Ensure workflow succeeds if MQTT commands were sent successfully
          exit 0

      - name: Generate deployment summary
        run: |
          # Determine which version was deployed (use env vars set in earlier steps)
          if [ "${{ env.FIRMWARE_EXISTS }}" = "true" ]; then
            DEPLOYED_VERSION="${{ env.EXISTING_VERSION }}"
          else
            DEPLOYED_VERSION="${{ env.VERSION }}"
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ESP OTA Deployment Summary
          
          ## Firmware Details
          - **Version**: \`${DEPLOYED_VERSION}\`
          - **Device Model**: \`${{ github.event.inputs.device_model }}\`
          - **Commit**: \`${{ env.COMMIT_HASH }}\`
          - **SHA256**: \`${{ env.FIRMWARE_SHA256 }}\`
          - **Build Status**: $([ "${{ env.FIRMWARE_EXISTS }}" = "true" ] && echo "Reused existing firmware" || echo "Newly built")
          
          ## Rollout Configuration
          - **Strategy**: \`${{ github.event.inputs.rollout_strategy }}\`
          EOF
          
          if [ "${{ github.event.inputs.rollout_strategy }}" = "single-device" ]; then
            echo "- **Target Devices**: \`${{ github.event.inputs.test_devices }}\`" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ github.event.inputs.rollout_strategy }}" == canary-* ]]; then
            PERCENTAGE=$(echo "${{ github.event.inputs.rollout_strategy }}" | cut -d- -f2)
            echo "- **Rollout Percentage**: ${PERCENTAGE}%" >> $GITHUB_STEP_SUMMARY
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          
          ## Release Notes
          ${{ github.event.inputs.release_notes }}
          
          ## Monitoring
          - Check OTA service: ${{ secrets.OTA_SERVICE_URL || 'http://localhost:8080' }}
          - View device status in database
          
          ## Next Steps
          1. Monitor device update progress
          2. Check for any failed updates
          3. If using canary rollout, gradually increase percentage after validation
          EOF

      - name: Notify on failure
        if: failure()
        run: |
          echo "::error::OTA deployment failed! Check logs for details."
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ❌ ESP OTA Deployment Failed
          
          The OTA deployment encountered an error. Please check the workflow logs for details.
          
          ## Troubleshooting
          - Verify OTA service is accessible at: ${{ secrets.OTA_SERVICE_URL || 'http://localhost:8080' }}
          - Check OTA_API_KEY is configured correctly in secrets
          - Ensure paku-core repository builds successfully
          - Review firmware build logs above
          EOF
