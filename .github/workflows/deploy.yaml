name: Deploy to Hetzner

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read

env:
  DEPLOY_PATH: /home/paku/paku-iot

jobs:
  deploy:
    name: Deploy to Hetzner VM
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

      - name: Deploy to server
        env:
          SSH_HOST: ${{ secrets.HETZNER_HOST }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          GF_SECURITY_ADMIN_PASSWORD: ${{ secrets.GF_SECURITY_ADMIN_PASSWORD }}
          OTA_API_KEY: ${{ secrets.OTA_API_KEY }}
          MQTT_USER: ${{ secrets.MQTT_USER }}
          MQTT_PASSWORD: ${{ secrets.MQTT_PASSWORD }}
          MQTT_CN: ${{ secrets.MQTT_CN }}
          PAKU_DOMAIN: ${{ secrets.PAKU_DOMAIN }}
          ECOFLOW_ACCESS_KEY: ${{ secrets.ECOFLOW_ACCESS_KEY }}
          ECOFLOW_SECRET_KEY: ${{ secrets.ECOFLOW_SECRET_KEY }}
          ECOFLOW_DEVICE_SN: ${{ secrets.ECOFLOW_DEVICE_SN }}
          ECOFLOW_API_URL: ${{ secrets.ECOFLOW_API_URL }}
        run: |
          # Create deployment script
          cat > /tmp/deploy.sh << 'DEPLOY_SCRIPT'
          #!/bin/bash
          set -e
          
          DEPLOY_PATH="${DEPLOY_PATH}"
          
          echo "=== Deploying paku-iot ==="
          
          # Clone or update repository
          if [ -d "$DEPLOY_PATH" ]; then
            echo "Updating existing deployment..."
            cd "$DEPLOY_PATH"
            git fetch origin main
            git reset --hard origin/main
          else
            echo "Creating new deployment..."
            git clone https://github.com/ychefla/paku-iot.git "$DEPLOY_PATH"
            cd "$DEPLOY_PATH"
          fi
          
          # Create .env file with production secrets
          # Use placeholders and sed to properly substitute variables
          cat > compose/.env << 'ENVFILE'
          # Production environment - auto-generated by GitHub Actions
          POSTGRES_USER=paku
          POSTGRES_PASSWORD=__POSTGRES_PASSWORD__
          POSTGRES_DB=paku
          
          MQTT_HOST=mosquitto
          MQTT_PORT=1883
          MQTT_USER=__MQTT_USER__
          MQTT_PASSWORD=__MQTT_PASSWORD__
          MQTT_CN=__MQTT_CN__
          
          GF_SECURITY_ADMIN_USER=admin
          GF_SECURITY_ADMIN_PASSWORD=__GF_SECURITY_ADMIN_PASSWORD__
          
          PAKU_DOMAIN=__PAKU_DOMAIN__
          
          # EcoFlow Configuration (optional - only used if secrets are set)
          ECOFLOW_ACCESS_KEY=__ECOFLOW_ACCESS_KEY__
          ECOFLOW_SECRET_KEY=__ECOFLOW_SECRET_KEY__
          ECOFLOW_DEVICE_SN=__ECOFLOW_DEVICE_SN__
          ECOFLOW_API_URL=__ECOFLOW_API_URL__
          
          # OTA Service Configuration
          OTA_API_KEY=__OTA_API_KEY__
          ENVFILE
          
          # Replace placeholders with actual values
          sed -i "s|__POSTGRES_PASSWORD__|${POSTGRES_PASSWORD}|g" compose/.env
          sed -i "s|__GF_SECURITY_ADMIN_PASSWORD__|${GF_SECURITY_ADMIN_PASSWORD}|g" compose/.env
          sed -i "s|__OTA_API_KEY__|${OTA_API_KEY}|g" compose/.env
          sed -i "s|__MQTT_USER__|${MQTT_USER:-paku}|g" compose/.env
          sed -i "s|__MQTT_PASSWORD__|${MQTT_PASSWORD}|g" compose/.env
          sed -i "s|__MQTT_CN__|${MQTT_CN:-paku-mqtt}|g" compose/.env
          sed -i "s|__PAKU_DOMAIN__|${PAKU_DOMAIN:-:80}|g" compose/.env
          sed -i "s|__ECOFLOW_ACCESS_KEY__|${ECOFLOW_ACCESS_KEY}|g" compose/.env
          sed -i "s|__ECOFLOW_SECRET_KEY__|${ECOFLOW_SECRET_KEY}|g" compose/.env
          sed -i "s|__ECOFLOW_DEVICE_SN__|${ECOFLOW_DEVICE_SN}|g" compose/.env
          sed -i "s|__ECOFLOW_API_URL__|${ECOFLOW_API_URL}|g" compose/.env
          
          chmod 600 compose/.env
          
          # Check if PostgreSQL data volume already exists
          # If so, we need to update the password to match the new secret
          if docker volume ls -q | grep -E '(compose_)?paku_pgdata' | head -1 | grep -q .; then
            echo "Existing PostgreSQL data volume found, updating password..."
            
            # Stop any running containers first
            docker compose -f compose/stack.prod.yaml down 2>/dev/null || true
            
            # Start only PostgreSQL
            docker compose -f compose/stack.prod.yaml up -d postgres
            
            # Wait for PostgreSQL to be ready
            echo "Waiting for PostgreSQL to be ready..."
            for i in {1..30}; do
              if docker exec paku_postgres pg_isready -U paku >/dev/null 2>&1; then
                echo "PostgreSQL is ready"
                break
              fi
              sleep 1
            done
            
            # Temporarily modify pg_hba.conf to allow trust authentication
            echo "Configuring temporary trust authentication..."
            docker exec paku_postgres bash -c 'cp /var/lib/postgresql/data/pg_hba.conf /var/lib/postgresql/data/pg_hba.conf.bak'
            # Prepend trust auth rule for local connections
            docker exec paku_postgres bash -c '
              echo "local all all trust" > /var/lib/postgresql/data/pg_hba.conf.tmp
              cat /var/lib/postgresql/data/pg_hba.conf >> /var/lib/postgresql/data/pg_hba.conf.tmp
              mv /var/lib/postgresql/data/pg_hba.conf.tmp /var/lib/postgresql/data/pg_hba.conf
            '
            
            # Reload PostgreSQL configuration by sending SIGHUP to the main process
            docker exec paku_postgres bash -c 'kill -HUP 1'
            sleep 2
            
            # Update the password for the paku user using local trust authentication
            # Use environment variable to avoid exposing password in command line
            echo "Updating PostgreSQL password..."
            docker exec -e PGPASSWORD_NEW="${POSTGRES_PASSWORD}" paku_postgres bash -c \
              'psql -U paku -d paku -c "ALTER USER paku WITH PASSWORD '"'"'$PGPASSWORD_NEW'"'"';"' || {
              echo "Warning: Could not update password. This may be a fresh install."
            }
            
            # Restore original pg_hba.conf
            echo "Restoring original authentication configuration..."
            docker exec paku_postgres bash -c 'mv /var/lib/postgresql/data/pg_hba.conf.bak /var/lib/postgresql/data/pg_hba.conf'
            docker exec paku_postgres bash -c 'kill -HUP 1'
            
            # Stop PostgreSQL - it will restart with normal auth during full deployment
            docker compose -f compose/stack.prod.yaml down
          fi
          
          # Build and deploy
          echo "Building and starting services..."
          docker compose -f compose/stack.prod.yaml pull 2>/dev/null || true
          docker compose -f compose/stack.prod.yaml build --no-cache
          
          # Start services - include EcoFlow profile if credentials are set
          if [ -n "${ECOFLOW_ACCESS_KEY}" ] && [ -n "${ECOFLOW_SECRET_KEY}" ]; then
            echo "EcoFlow credentials found - starting with ecoflow profile..."
            docker compose -f compose/stack.prod.yaml --profile ecoflow up -d
          else
            echo "No EcoFlow credentials - starting without ecoflow profile..."
            docker compose -f compose/stack.prod.yaml up -d
          fi
          
          # Wait for services to be healthy
          echo "Waiting for services to be healthy..."
          sleep 10
          
          # Check service status
          echo "=== Service Status ==="
          docker compose -f compose/stack.prod.yaml ps
          
          # Clean up old images
          docker image prune -f
          
          echo "=== Deployment complete ==="
          DEPLOY_SCRIPT
          
          # Copy and execute deployment script
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=accept-new /tmp/deploy.sh paku@${SSH_HOST}:/tmp/deploy.sh
          
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=accept-new paku@${SSH_HOST} "
            export DEPLOY_PATH='${DEPLOY_PATH}'
            export POSTGRES_PASSWORD='${POSTGRES_PASSWORD}'
            export GF_SECURITY_ADMIN_PASSWORD='${GF_SECURITY_ADMIN_PASSWORD}'
            export OTA_API_KEY='${OTA_API_KEY}'
            export MQTT_USER='${MQTT_USER:-paku}'
            export MQTT_PASSWORD='${MQTT_PASSWORD}'
            export MQTT_CN='${MQTT_CN:-paku-mqtt}'
            export PAKU_DOMAIN='${PAKU_DOMAIN:-:80}'
            export ECOFLOW_ACCESS_KEY='${ECOFLOW_ACCESS_KEY}'
            export ECOFLOW_SECRET_KEY='${ECOFLOW_SECRET_KEY}'
            export ECOFLOW_DEVICE_SN='${ECOFLOW_DEVICE_SN}'
            export ECOFLOW_API_URL='${ECOFLOW_API_URL}'
            chmod +x /tmp/deploy.sh
            /tmp/deploy.sh
            rm /tmp/deploy.sh
          "

      - name: Verify deployment
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=accept-new paku@${{ secrets.HETZNER_HOST }} "
            cd ${DEPLOY_PATH}
            echo '=== Container Health Check ==='
            docker compose -f compose/stack.prod.yaml ps --format 'table {{.Name}}\t{{.Status}}\t{{.Ports}}'
            
            echo ''
            echo '=== Recent Logs ==='
            docker compose -f compose/stack.prod.yaml logs --tail=5
          "

      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
