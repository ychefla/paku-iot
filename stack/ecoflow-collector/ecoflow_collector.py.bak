"""
EcoFlow Collector Service

Connects to EcoFlow Cloud API to obtain MQTT credentials,
then subscribes to EcoFlow MQTT broker to receive real-time
power station data and writes it to the Postgres database.

Environment variables (set via docker compose):

    ECOFLOW_ACCESS_KEY - EcoFlow Developer API access key
    ECOFLOW_SECRET_KEY - EcoFlow Developer API secret key
    ECOFLOW_DEVICE_SN - Device serial number (optional, for filtering)

    PGHOST
    PGPORT
    PGUSER
    PGPASSWORD
    PGDATABASE
"""

import hashlib
import hmac
import json
import logging
import os
import random
import ssl
import string
import sys
import time
from typing import Any, Dict, Optional

import paho.mqtt.client as mqtt
from paho.mqtt.client import CallbackAPIVersion
import psycopg
import requests


# ---------------------------------------------------------------------
# Logging setup
# ---------------------------------------------------------------------
logging.basicConfig(
    level=logging.DEBUG,  # Changed to DEBUG for more verbose output
    format="%(asctime)s [%(levelname)s] %(name)s - %(message)s",
    stream=sys.stdout,
)
logger = logging.getLogger("paku-ecoflow-collector")


# ---------------------------------------------------------------------
# Configuration helpers
# ---------------------------------------------------------------------
def get_env(name: str, default: Optional[str] = None) -> str:
    value = os.getenv(name, default)
    if value is None:
        logger.error("Required environment variable %s is not set", name)
        raise RuntimeError(f"Missing environment variable: {name}")
    return value


def load_config() -> Dict[str, Any]:
    return {
        "ecoflow_access_key": get_env("ECOFLOW_ACCESS_KEY"),
        "ecoflow_secret_key": get_env("ECOFLOW_SECRET_KEY"),
        "ecoflow_device_sn": os.getenv("ECOFLOW_DEVICE_SN", ""),
        # Default to US API endpoint - use https://api-e.ecoflow.com for EU
        "ecoflow_api_url": os.getenv("ECOFLOW_API_URL", "https://api.ecoflow.com"),
        "pg_host": get_env("PGHOST", "postgres"),
        "pg_port": int(os.getenv("PGPORT", "5432")),
        "pg_user": get_env("PGUSER"),
        "pg_password": get_env("PGPASSWORD"),
        "pg_database": get_env("PGDATABASE"),
    }


# ---------------------------------------------------------------------
# EcoFlow API integration
# ---------------------------------------------------------------------
class EcoFlowAPI:
    """Helper class to interact with EcoFlow Developer API."""
    
    def __init__(self, access_key: str, secret_key: str, base_url: Optional[str] = None):
        self.access_key = access_key
        self.secret_key = secret_key
        # Support regional endpoints: US (default), EU, or custom
        self.base_url = base_url or "https://api.ecoflow.com"
    
    def _generate_sign(self, params: Dict[str, str]) -> str:
        """
        Generate HMAC-SHA256 signature for EcoFlow API request.
        
        The signature is computed from a sorted, concatenated string of parameters.
        """
        # Sort parameters by key
        sorted_params = sorted(params.items())
        # Concatenate as key=value pairs
        param_str = "&".join(f"{k}={v}" for k, v in sorted_params)
        # Create HMAC-SHA256 signature
        signature = hmac.new(
            self.secret_key.encode('utf-8'),
            param_str.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
        return signature
    
    def get_mqtt_credentials(self) -> Dict[str, Any]:
        """
        Request MQTT credentials from EcoFlow API.
        
        Returns dict with: url, port, username, password, protocol, clientId
        """
        # Generate request parameters
        nonce = ''.join(random.choices(string.ascii_letters + string.digits, k=16))
        timestamp = str(int(time.time() * 1000))  # milliseconds
        
        # Build parameters for signature
        params = {
            "accessKey": self.access_key,
            "nonce": nonce,
            "timestamp": timestamp
        }
        
        # Generate signature
        sign = self._generate_sign(params)
        
        # Make GET request with parameters as headers (required by EU API)
        url = f"{self.base_url}/iot-open/sign/certification"
        headers = {
            "accessKey": self.access_key,
            "nonce": nonce,
            "timestamp": timestamp,
            "sign": sign
        }
        
        logger.info("Requesting MQTT credentials from EcoFlow API...")
        logger.debug("API endpoint: %s", url)
        response = requests.get(url, headers=headers, timeout=30)
        
        if response.status_code != 200:
            logger.error("Failed to get MQTT credentials: HTTP %s - %s", 
                        response.status_code, response.text)
            raise RuntimeError(f"EcoFlow API error: {response.status_code}")
        
        data = response.json()
        
        if data.get("code") != "0":
            logger.error("EcoFlow API returned error: %s", data)
            raise RuntimeError(f"EcoFlow API error: {data.get('message', 'Unknown error')}")
        
        mqtt_data = data.get("data", {})
        logger.info("Successfully obtained MQTT credentials")
        logger.debug("MQTT info: host=%s port=%s", mqtt_data.get("url"), mqtt_data.get("port"))
        
        return mqtt_data


# ---------------------------------------------------------------------
# Database handling
# ---------------------------------------------------------------------
def connect_to_database(cfg: Dict[str, Any]) -> psycopg.Connection:
    logger.info(
        "Connecting to Postgres at %s:%s db=%s",
        cfg["pg_host"],
        cfg["pg_port"],
        cfg["pg_database"],
    )
    conn = psycopg.connect(
        host=cfg["pg_host"],
        port=cfg["pg_port"],
        user=cfg["pg_user"],
        password=cfg["pg_password"],
        dbname=cfg["pg_database"],
        autocommit=True,
    )
    return conn


def insert_ecoflow_measurement(conn: psycopg.Connection, data: Dict[str, Any]) -> None:
    """
    Insert EcoFlow power station measurement into the database.
    
    Enhanced to handle all available fields from comprehensive parsing.
    Uses INSERT ... ON CONFLICT to update existing recent measurement with new data,
    aggregating values from multiple MQTT messages into a single row.
    """
    # Define all possible fields
    
    # Only insert if we have at least one meaningful value
    has_data = any([data.get(k) is not None for k in all_fields])
    
    if not has_data:
        logger.debug("Skipping insert - no meaningful data in payload")
        return
    
    with conn.cursor() as cur:
        # Check if there's a recent measurement (within last 10 seconds) to update
        cur.execute(
            """
            SELECT id FROM ecoflow_measurements
            WHERE device_sn = %(device_sn)s
              AND ts >= NOW() - INTERVAL '10 seconds'
            ORDER BY ts DESC
            LIMIT 1
            """,
            {"device_sn": data["device_sn"]}
        )
        recent_row = cur.fetchone()
        
        if recent_row:
            # Update existing row with new non-null values
            update_fields = []
            update_params = {"id": recent_row[0]}
            
            for field in all_fields:
                if data.get(field) is not None:
                    update_fields.append(f"{field} = COALESCE(%({field})s, {field})")
                    update_params[field] = data[field]
            
            # Always append to raw_data
            if data.get('raw_data'):
                update_fields.append("raw_data = raw_data || %(raw_data)s::jsonb")
                update_params['raw_data'] = data['raw_data']
            
            if update_fields:
                query = f"""
                UPDATE ecoflow_measurements
                SET {', '.join(update_fields)}, ts = NOW()
                WHERE id = %(id)s
                """
                cur.execute(query, update_params)
                logger.debug("Updated recent measurement id=%s with %d fields", recent_row[0], len(update_fields))
        else:
            # Prepare insert with only non-null fields
            insert_fields = ['device_sn', 'ts'] + [f for f in all_fields if data.get(f) is not None]
            if data.get('raw_data'):
                insert_fields.append('raw_data')
            
            placeholders = ['%(device_sn)s', 'NOW()'] + [f'%({f})s' for f in all_fields if data.get(f) is not None]
            if data.get('raw_data'):
                placeholders.append('%(raw_data)s')
            
            query = f"""
                INSERT INTO ecoflow_measurements (
                    {', '.join(insert_fields)}
                )
                VALUES (
                    {', '.join(placeholders)}
                )
            """
            cur.execute(query, data)
            logger.debug("Inserted new measurement with %d fields", len(insert_fields))


def parse_ecoflow_payload(raw_payload: Dict[str, Any], device_sn: str = "") -> Dict[str, Any]:
    """
    Parse EcoFlow MQTT payload into our database schema.
    
    EcoFlow sends complex nested structures with dotted field names.
    Example: {"params": {"bmsMaster.soc": 89, "bmsMaster.inputWatts": 0, ...}}
    
    COMPREHENSIVE parser - extracts ALL available real-time data fields.
    """
    # EcoFlow typically nests data in a "params" or "data" field
    params = raw_payload.get("params", {})
    
    # Helper to safely get numeric values - ACCEPTS ZERO VALUES
    def get_val(key, default=None):
        val = params.get(key, default)
        # Filter out obviously invalid values
        if val is not None and isinstance(val, (int, float)):
            # Some fields use 65535 or 4294967295 as "not available"
            if val >= 4294967295 or val == 65535:
                return None
        return val
    
    # Helper to sum multiple ports - ACCEPTS ZEROS
    def sum_ports(keys):
        total = 0
        found_any = False
        for key in keys:
            val = get_val(key)
            if val is not None:
                total += val
                found_any = True
        return total if found_any else None
    
    # Helper to get first non-None value from list
    def first_of(*keys):
        for key in keys:
            val = get_val(key)
            if val is not None:
                return val
        return None
    
    # Extract ALL values from dotted field names
    # Primary power metrics
    soc_val = first_of("pd.soc", "bmsMaster.soc", "ems.lcdShowSoc", "soc")
    remain_time_val = first_of("pd.remainTime", "bmsMaster.remainTime", 
                              "ems.chgRemainTime", "ems.dsgRemainTime", "remainTime")
    watts_in = first_of("pd.wattsInSum", "inv.inputWatts", "mppt.inWatts", 
                       "bmsMaster.inputWatts", "wattsInSum")
    watts_out = first_of("pd.wattsOutSum", "inv.outputWatts", 
                        "bmsMaster.outputWatts", "wattsOutSum")
    
    # Individual output channels
    ac_out = first_of("inv.outputWatts", "inv.invOutWatts", "pd.dsgPowerAc")
    dc_out = first_of("mppt.carOutWatts", "mppt.outWatts", "pd.dsgPowerDc")
    typec_watts = sum_ports(["pd.typec1Watts", "pd.typec2Watts"])
    usb_watts = sum_ports(["pd.usb1Watts", "pd.usb2Watts", "pd.qcUsb1Watts", "pd.qcUsb2Watts"])
    
    # Individual USB port details
    usb1_watts = get_val("pd.usb1Watts")
    usb2_watts = get_val("pd.usb2Watts")
    qcusb1_watts = get_val("pd.qcUsb1Watts")
    qcusb2_watts = get_val("pd.qcUsb2Watts")
    typec1_watts = get_val("pd.typec1Watts")
    typec2_watts = get_val("pd.typec2Watts")
    typec1_temp = get_val("pd.typec1Temp")
    typec2_temp = get_val("pd.typec2Temp")
    
    # Solar/PV input
    pv_in = first_of("mppt.inWatts", "mppt.pv1InputWatts", "pd.chgSunPower", "pvInWatts")
    chg_sun_power = get_val("pd.chgSunPower")
    chg_power_ac = get_val("pd.chgPowerAc")
    chg_power_dc = get_val("pd.chgPowerDc")
    
    # Car output watts
    car_watts = get_val("pd.carWatts")
    
    # BMS (Battery Management System) - COMPREHENSIVE extraction
    bms_vol = get_val("bmsMaster.vol")
    bms_amp = get_val("bmsMaster.amp")
    bms_temp = get_val("bmsMaster.temp")
    bms_min_cell_temp = get_val("bmsMaster.minCellTemp")
    bms_max_cell_temp = get_val("bmsMaster.maxCellTemp")
    bms_min_mos_temp = get_val("bmsMaster.minMosTemp")
    bms_max_mos_temp = get_val("bmsMaster.maxMosTemp")
    bms_cycles = get_val("bmsMaster.cycles")
    bms_soh = get_val("bmsMaster.soh")
    bms_real_soh = get_val("bmsMaster.realSoh")
    bms_remain_cap = get_val("bmsMaster.remainCap")
    bms_full_cap = get_val("bmsMaster.fullCap")
    bms_design_cap = get_val("bmsMaster.designCap")
    bms_min_cell_vol = get_val("bmsMaster.minCellVol")
    bms_max_cell_vol = get_val("bmsMaster.maxCellVol")
    bms_max_vol_diff = get_val("bmsMaster.maxVolDiff")
    
    # EMS (Energy Management System) settings
    ems_min_dsg_soc = get_val("ems.minDsgSoc")
    ems_max_charge_soc = get_val("ems.maxChargeSoc")
    ems_min_open_oil_eb_soc = get_val("ems.minOpenOilEbSoc")
    ems_max_close_oil_eb_soc = get_val("ems.maxCloseOilEbSoc")
    
    # Inverter data - COMPREHENSIVE
    inv_ac_in_vol = get_val("inv.acInVol")
    inv_ac_out_vol = first_of("inv.invOutVol", "inv.acOutVol")
    inv_ac_freq = first_of("inv.acInFreq", "inv.invOutFreq")
    inv_temp = first_of("inv.outTemp", "inv.dcInTemp")
    inv_cfg_ac_enabled = get_val("inv.cfgAcEnabled")
    inv_cfg_standby_min = get_val("inv.cfgStandbyMin")
    
    # MPPT (Solar controller) - COMPREHENSIVE
    mppt_in_vol = get_val("mppt.inVol")
    mppt_in_amp = get_val("mppt.inAmp")
    mppt_out_vol = get_val("mppt.outVol")
    mppt_out_amp = get_val("mppt.outAmp")
    mppt_temp = get_val("mppt.mpptTemp")
    mppt_car_out_vol = get_val("mppt.carOutVol")
    mppt_car_out_amp = get_val("mppt.carOutAmp")
    mppt_car_state = get_val("mppt.carState")
    mppt_cfg_dc_chg_current = get_val("mppt.cfgDcChgCurrent")
    
    # PD (Power Distribution) settings and status
    pd_beep_state = get_val("pd.beepState")
    pd_lcd_off_sec = get_val("pd.lcdOffSec")
    pd_lcd_brightness = get_val("pd.lcdBrightness")
    pd_standby_mode = get_val("pd.standByMode")
    pd_wifi_rssi = get_val("pd.wifiRssi")
    pd_model = get_val("pd.model")
    pd_sys_ver = get_val("pd.sysVer")
    pd_wifi_ver = get_val("pd.wifiVer")
    
    # Usage time counters (in seconds typically)
    pd_car_used_time = get_val("pd.carUsedTime")
    pd_inv_used_time = get_val("pd.invUsedTime")
    pd_mppt_used_time = get_val("pd.mpptUsedTime")
    pd_usb_used_time = get_val("pd.usbUsedTime")
    pd_typec_used_time = get_val("pd.typccUsedTime")
    pd_dc_in_used_time = get_val("pd.dcInUsedTime")
    
    parsed = {
        "device_sn": device_sn or raw_payload.get("sn", "unknown"),
        # Core metrics
        "soc_percent": soc_val,
        "remain_time_min": remain_time_val,
        "watts_in_sum": watts_in,
        "watts_out_sum": watts_out,
        # Output channels
        "ac_out_watts": ac_out,
        "dc_out_watts": dc_out,
        "typec_out_watts": typec_watts,
        "usb_out_watts": usb_watts,
        # Individual ports
        "usb1_watts": usb1_watts,
        "usb2_watts": usb2_watts,
        "qcusb1_watts": qcusb1_watts,
        "qcusb2_watts": qcusb2_watts,
        "typec1_watts": typec1_watts,
        "typec2_watts": typec2_watts,
        "typec1_temp": typec1_temp,
        "typec2_temp": typec2_temp,
        # Input sources
        "pv_in_watts": pv_in,
        "chg_sun_power": chg_sun_power,
        "chg_power_ac": chg_power_ac,
        "chg_power_dc": chg_power_dc,
        "car_watts": car_watts,
        # BMS data
        "bms_voltage_mv": bms_vol,
        "bms_amp_ma": bms_amp,
        "bms_temp_c": bms_temp,
        "bms_min_cell_temp_c": bms_min_cell_temp,
        "bms_max_cell_temp_c": bms_max_cell_temp,
        "bms_min_mos_temp_c": bms_min_mos_temp,
        "bms_max_mos_temp_c": bms_max_mos_temp,
        "bms_cycles": bms_cycles,
        "bms_soh_percent": bms_soh,
        "bms_real_soh": bms_real_soh,
        "bms_remain_cap": bms_remain_cap,
        "bms_full_cap": bms_full_cap,
        "bms_design_cap": bms_design_cap,
        "bms_min_cell_vol_mv": bms_min_cell_vol,
        "bms_max_cell_vol_mv": bms_max_cell_vol,
        "bms_max_vol_diff_mv": bms_max_vol_diff,
        # EMS settings
        "ems_min_dsg_soc": ems_min_dsg_soc,
        "ems_max_charge_soc": ems_max_charge_soc,
        "ems_min_open_oil_eb_soc": ems_min_open_oil_eb_soc,
        "ems_max_close_oil_eb_soc": ems_max_close_oil_eb_soc,
        # Inverter data
        "inv_ac_in_volts_mv": inv_ac_in_vol,
        "inv_ac_out_volts_mv": inv_ac_out_vol,
        "inv_ac_freq_hz": inv_ac_freq,
        "inv_temp_c": inv_temp,
        "inv_cfg_ac_enabled": inv_cfg_ac_enabled,
        "inv_cfg_standby_min": inv_cfg_standby_min,
        # MPPT data
        "mppt_in_volts_mv": mppt_in_vol,
        "mppt_in_amps_ma": mppt_in_amp,
        "mppt_out_volts_mv": mppt_out_vol,
        "mppt_out_amps_ma": mppt_out_amp,
        "mppt_temp_c": mppt_temp,
        "mppt_car_out_volts_mv": mppt_car_out_vol,
        "mppt_car_out_amps_ma": mppt_car_out_amp,
        "mppt_car_state": mppt_car_state,
        "mppt_cfg_dc_chg_current": mppt_cfg_dc_chg_current,
        # PD settings and WiFi
        "pd_beep_state": pd_beep_state,
        "pd_lcd_off_sec": pd_lcd_off_sec,
        "pd_lcd_brightness": pd_lcd_brightness,
        "pd_standby_mode": pd_standby_mode,
        "wifi_rssi": pd_wifi_rssi,
        "pd_model": pd_model,
        "pd_sys_ver": pd_sys_ver,
        "pd_wifi_ver": pd_wifi_ver,
        # Usage time counters
        "pd_car_used_time": pd_car_used_time,
        "pd_inv_used_time": pd_inv_used_time,
        "pd_mppt_used_time": pd_mppt_used_time,
        "pd_usb_used_time": pd_usb_used_time,
        "pd_typec_used_time": pd_typec_used_time,
        "pd_dc_in_used_time": pd_dc_in_used_time,
        # Store full raw payload
        "raw_data": json.dumps(raw_payload),
    }
    
    return parsed



# ---------------------------------------------------------------------
# MQTT callbacks
# ---------------------------------------------------------------------
class EcoFlowCollectorApp:
    def __init__(self, cfg: Dict[str, Any]) -> None:
        self.cfg = cfg
        self.conn: Optional[psycopg.Connection] = None
        self.mqtt_credentials: Optional[Dict[str, Any]] = None
        self.client: Optional[mqtt.Client] = None
        self.device_sn = cfg.get("ecoflow_device_sn", "")
    
    def _ensure_db_connection(self):
        """Ensure database connection is alive, reconnect if needed."""
        try:
            if self.conn is None or self.conn.closed:
                logger.warning("Database connection is closed, reconnecting...")
                self.conn = connect_to_database(self.cfg)
                return
            
            # Test the connection
            with self.conn.cursor() as cur:
                cur.execute("SELECT 1")
        except Exception as exc:
            logger.warning("Database connection test failed: %s, reconnecting...", exc)
            try:
                if self.conn:
                    self.conn.close()
            except:
                pass
            self.conn = connect_to_database(self.cfg)
    
    def start(self) -> None:
        # Connect to database
        self.conn = connect_to_database(self.cfg)
        
        # Get MQTT credentials from EcoFlow API
        # Use configured API URL (defaults to EU endpoint)
        api_url = self.cfg.get("ecoflow_api_url", "https://api-e.ecoflow.com")
        api = EcoFlowAPI(
            self.cfg["ecoflow_access_key"],
            self.cfg["ecoflow_secret_key"],
            api_url
        )
        self.mqtt_credentials = api.get_mqtt_credentials()
        
        # Setup MQTT client
        client_id = self.mqtt_credentials.get("clientId", "paku-ecoflow-collector")
        self.client = mqtt.Client(
            client_id=client_id,
            callback_api_version=CallbackAPIVersion.VERSION2
        )
        
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message
        self.client.on_disconnect = self.on_disconnect
        self.client.on_subscribe = self.on_subscribe
        
        # Setup TLS with proper certificate verification
        self.client.tls_set(cert_reqs=ssl.CERT_REQUIRED)
        
        # Setup credentials (certificateAccount and certificatePassword from API)
        username = self.mqtt_credentials.get("certificateAccount") or self.mqtt_credentials.get("username")
        password = self.mqtt_credentials.get("certificatePassword") or self.mqtt_credentials.get("password")
        self.client.username_pw_set(username, password)
        
        # Connect
        host = self.mqtt_credentials.get("url", "mqtt.ecoflow.com")
        port = int(self.mqtt_credentials.get("port", 8883))
        
        logger.info("Connecting to EcoFlow MQTT broker at %s:%s", host, port)
        self.client.connect(host, port, keepalive=60)
        self.client.loop_forever()
    
    def on_connect(self, client, userdata, flags, reason_code, properties):
        if reason_code.is_failure:
            logger.error("Failed to connect to EcoFlow MQTT broker: %s", reason_code)
        else:
            logger.info("Connected to EcoFlow MQTT broker")
            logger.info("MQTT credentials info: certificateAccount=%s", self.mqtt_credentials.get("certificateAccount", "N/A"))
            
            # Subscribe to device topic(s)
            # EcoFlow topic format varies by region and API version
            # Based on the documentation, try multiple patterns to catch messages
            
            # Extract user ID from certificateAccount (format is often "userId/randomString")
            cert_account = self.mqtt_credentials.get("certificateAccount", "")
            if "/" in cert_account:
                user_id = cert_account.split("/")[0]
                logger.info("Extracted user_id from certificateAccount: %s", user_id)
            else:
                user_id = cert_account
                logger.info("Using full certificateAccount as user_id: %s", user_id)
            
            # Subscribe to multiple topic patterns to ensure we catch messages
            topics = []
            
            if self.device_sn:
                # Standard OpenAPI topics for device properties and quotas
                topics.extend([
                    f"/app/{user_id}/{self.device_sn}/#",  # All device messages
                    f"/app/device/property/{self.device_sn}",  # Simplified property format
                    f"/open/{user_id}/{self.device_sn}/quota",  # Quota updates
                ])
            
            # Also subscribe to global wildcard to debug what topics are actually used
            topics.append("#")  # ALL topics - for debugging
            
            logger.info("Subscribing to %d topic patterns", len(topics))
            for topic in topics:
                result = client.subscribe(topic, qos=0)
                logger.info("Subscribed to topic: %s (result: %s)", topic, result)
    
    def on_subscribe(self, client, userdata, mid, reason_code_list, properties):
        logger.info("Subscription confirmed: mid=%s, codes=%s", mid, reason_code_list)
    
    def on_disconnect(self, client, userdata, disconnect_flags, reason_code, properties):
        logger.warning("Disconnected from EcoFlow MQTT broker, reason_code=%s", reason_code)
    
    def on_message(self, client, userdata, msg):
        payload_raw = msg.payload.decode("utf-8", errors="replace")
        logger.info("Received MQTT message on topic: %s (payload size: %d bytes)", msg.topic, len(payload_raw))
        logger.debug("Payload preview: %s", payload_raw[:200])
        
        try:
            data = json.loads(payload_raw)
        except json.JSONDecodeError:
            logger.warning("Failed to decode JSON payload: %s", payload_raw[:100])
            return
        
        if not isinstance(data, dict):
            logger.warning("Expected JSON object, got: %r", type(data))
            return
        
        # Parse topic to extract device serial number if not configured
        device_sn = self.device_sn
        if not device_sn:
            # Try to extract from topic: /app/{user_id}/{device_sn}/...
            parts = msg.topic.split("/")
            logger.debug("Topic parts: %s", parts)
            if len(parts) > 3:
                device_sn = parts[3]
                logger.info("Extracted device SN from topic: %s", device_sn)
        
        # Ensure database connection is alive
        try:
            self._ensure_db_connection()
        except Exception as exc:
            logger.error("Failed to ensure DB connection: %s; dropping message", exc)
            return
        
        if self.conn is None:
            logger.error("No DB connection available; dropping message")
            return
        
        try:
            parsed_data = parse_ecoflow_payload(data, device_sn)
            logger.info("Parsed data fields: %s", {k: v for k, v in parsed_data.items() if k != 'raw_data'})
            insert_ecoflow_measurement(self.conn, parsed_data)
            logger.info(
                "Inserted EcoFlow measurement for device=%s, soc=%s%%",
                device_sn,
                parsed_data.get("soc_percent")
            )
        except Exception as exc:
            logger.exception("Failed to insert EcoFlow measurement: %s", exc)


# ---------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------
def main() -> None:
    logger.info("Starting EcoFlow Collector Service")
    
    try:
        cfg = load_config()
        app = EcoFlowCollectorApp(cfg)
        app.start()
    except KeyboardInterrupt:
        logger.info("Shutting down due to keyboard interrupt")
    except Exception as exc:
        logger.exception("Fatal error: %s", exc)
        sys.exit(1)


if __name__ == "__main__":
    main()
