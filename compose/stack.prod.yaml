# ------------------------------------------------------------
# PAKU IoT – PRODUCTION STACK
#
# Production-ready stack for deployment on a Hetzner VM.
# Based on the unified stack with production optimizations:
#   - Resource limits
#   - Restart policies
#   - Health checks
#   - Logging configuration
#
# Environment variables are loaded from .env file in same directory
# ------------------------------------------------------------

services:
  # ------------------------------------------------------------
  # MOSQUITTO MQTT BROKER
  # Receives messages from IoT devices.
  # The collector service subscribes here.
  # ------------------------------------------------------------
  mosquitto:
    build:
      context: ../stack/mosquitto
      args:
        MQTT_USER: ${MQTT_USER:-paku}
        MQTT_PASSWORD: ${MQTT_PASSWORD}
        MQTT_CN: ${MQTT_CN:-paku-mqtt}
    container_name: paku_mosquitto
    restart: always
    ports:
      - "1883:1883"
      - "8883:8883"
    volumes:
      - paku_mqttdata:/mosquitto/data
    deploy:
      resources:
        limits:
          memory: 128M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    healthcheck:
      test: ["CMD", "mosquitto_sub", "-t", "$$SYS/#", "-C", "1", "-W", "3"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # ------------------------------------------------------------
  # POSTGRES – PERSISTENT STORAGE
  # Stores all sensor data.
  # The paku_pgdata volume ensures data persists across restarts.
  # ------------------------------------------------------------
  postgres:
    build:
      context: ../stack/postgres
    container_name: paku_postgres
    restart: always
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-paku}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB:-paku}
    ports:
      - "127.0.0.1:5432:5432"
    volumes:
      - paku_pgdata:/var/lib/postgresql/data
      - paku_backups:/backups
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-paku} -d ${POSTGRES_DB:-paku}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  # ------------------------------------------------------------
  # GRAFANA
  # Visualization layer that reads from Postgres.
  # The paku_grafana volume stores dashboards and Grafana state.
  # ------------------------------------------------------------
  grafana:
    build:
      context: ../stack/grafana
    container_name: paku_grafana
    restart: always
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      GF_SECURITY_ADMIN_USER: ${GF_SECURITY_ADMIN_USER:-admin}
      GF_SECURITY_ADMIN_PASSWORD: ${GF_SECURITY_ADMIN_PASSWORD}
      GF_SERVER_ROOT_URL: ${GF_SERVER_ROOT_URL:-http://localhost:3000}
      POSTGRES_USER: ${POSTGRES_USER:-paku}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB:-paku}
    # Port exposed via Caddy reverse proxy — no direct access
    # ports:
    #   - "3000:3000"
    volumes:
      - paku_grafana:/var/lib/grafana
    deploy:
      resources:
        limits:
          memory: 256M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  # ------------------------------------------------------------
  # RUUVITAG EMULATOR
  # Sends fake sensor data to MQTT for testing.
  # NOTE: In production, you may want to disable this and use
  # real IoT devices instead.
  # Runs for 5 minutes then exits automatically.
  # Publishes to paku/ruuvi/van_inside every 5-10 seconds.
  # ------------------------------------------------------------
  #ruuvi-emulator:
  #  build:
  #    context: ../stack/ruuvi-emulator
  #  container_name: paku_ruuvi_emulator
  #  restart: "no"
  #  depends_on:
  #    mosquitto:
  #      condition: service_healthy
  #  environment:
  #    MQTT_HOST: mosquitto
  #    MQTT_PORT: 1883
  #    MAX_RUNTIME_SECONDS: ${MAX_RUNTIME_SECONDS:-300}
  #  deploy:
  #    resources:
  #      limits:
  #        memory: 64M
  #  logging:
  #    driver: "json-file"
  #    options:
  #      max-size: "10m"
  #      max-file: "3"

  # ------------------------------------------------------------
  # COLLECTOR
  # Reads MQTT messages from Mosquitto and writes them to Postgres.
  # Subscribes to paku/ruuvi/van_inside and inserts data into the
  # measurements table.
  # ------------------------------------------------------------
  collector:
    build:
      context: ../stack/collector
    container_name: paku_collector
    restart: always
    depends_on:
      mosquitto:
        condition: service_healthy
      postgres:
        condition: service_healthy
    environment:
      MQTT_HOST: mosquitto
      MQTT_PORT: 1883
      MQTT_USER: ${MQTT_USER:-paku}
      MQTT_PASSWORD: ${MQTT_PASSWORD}
      MQTT_TOPIC_PATTERN: "+/+/+/data"
      PGHOST: postgres
      PGPORT: 5432
      PGUSER: ${POSTGRES_USER:-paku}
      PGPASSWORD: ${POSTGRES_PASSWORD}
      PGDATABASE: ${POSTGRES_DB:-paku}
    deploy:
      resources:
        limits:
          memory: 128M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # ------------------------------------------------------------
  # ECOFLOW COLLECTOR (OPTIONAL)
  # Connects to EcoFlow Cloud API to collect power station data.
  # Enabled via Docker Compose profile when credentials are set.
  # ------------------------------------------------------------
  ecoflow-collector:
    build:
      context: ../stack/ecoflow-collector
    container_name: paku_ecoflow_collector
    restart: always
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      ECOFLOW_ACCESS_KEY: ${ECOFLOW_ACCESS_KEY:-}
      ECOFLOW_SECRET_KEY: ${ECOFLOW_SECRET_KEY:-}
      ECOFLOW_DEVICE_SN: ${ECOFLOW_DEVICE_SN:-}
      ECOFLOW_API_URL: ${ECOFLOW_API_URL:-}
      PGHOST: postgres
      PGPORT: 5432
      PGUSER: ${POSTGRES_USER:-paku}
      PGPASSWORD: ${POSTGRES_PASSWORD}
      PGDATABASE: ${POSTGRES_DB:-paku}
    deploy:
      resources:
        limits:
          memory: 128M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # ------------------------------------------------------------
  # OTA SERVICE
  # REST API for Over-The-Air firmware updates for ESP devices.
  # Provides endpoints for firmware hosting, version management,
  # rollout orchestration, and update status tracking.
  # ------------------------------------------------------------
  ota-service:
    build:
      context: ../stack/ota-service
    container_name: paku_ota_service
    restart: always
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      PGHOST: postgres
      PGPORT: 5432
      PGUSER: ${POSTGRES_USER:-paku}
      PGPASSWORD: ${POSTGRES_PASSWORD}
      PGDATABASE: ${POSTGRES_DB:-paku}
      FIRMWARE_STORAGE_PATH: /firmware
      API_KEY: ${OTA_API_KEY:-}
      PORT: 8080
    # Port exposed via Caddy reverse proxy — no direct access
    # ports:
    #   - \"8080:8080\"
    volumes:
      - paku_firmware:/firmware
    deploy:
      resources:
        limits:
          memory: 256M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 20s

  # ------------------------------------------------------------
  # PG-BACKUP
  # Runs daily pg_dump inside the postgres container via
  # docker exec, keeping the last 7 days of backups.
  # Backups are stored in the paku_backups volume.
  # To restore: docker exec paku_postgres sh -c 'gunzip -c /backups/<file> | psql -U paku paku'
  # ------------------------------------------------------------
  pg-backup:
    image: docker:cli
    container_name: paku_pg_backup
    restart: always
    depends_on:
      postgres:
        condition: service_healthy
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    entrypoint: |
      sh -c 'while true; do
        echo "[pg-backup] Starting backup at $$(date -Iseconds)";
        docker exec paku_postgres /usr/local/bin/backup.sh 2>&1 || true;
        echo "[pg-backup] Next backup in 24h";
        sleep 86400;
      done'
    deploy:
      resources:
        limits:
          memory: 64M
    logging:
      driver: "json-file"
      options:
        max-size: "5m"
        max-file: "2"

  # ------------------------------------------------------------
  # CADDY – REVERSE PROXY + AUTOMATIC TLS
  # Terminates HTTPS for Grafana (and optionally OTA service).
  # Set PAKU_DOMAIN in .env to your domain for automatic Let's Encrypt.
  # Without a domain, Caddy serves on :80 only.
  # ------------------------------------------------------------
  caddy:
    image: caddy:2-alpine
    container_name: paku_caddy
    restart: always
    depends_on:
      grafana:
        condition: service_healthy
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ../stack/caddy/Caddyfile:/etc/caddy/Caddyfile:ro
      - paku_caddy_data:/data
      - paku_caddy_config:/config
    environment:
      PAKU_DOMAIN: ${PAKU_DOMAIN:-:80}
    deploy:
      resources:
        limits:
          memory: 128M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

# ------------------------------------------------------------
# VOLUMES
# Centralized definitions for all persistent data directories.
# ------------------------------------------------------------
volumes:
  paku_pgdata:
  paku_grafana:
  paku_firmware:
  paku_mqttdata:
  paku_backups:
  paku_caddy_data:
  paku_caddy_config:
